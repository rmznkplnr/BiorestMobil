import { BleManager, Device, State } from 'react-native-ble-plx';
import { Buffer } from 'buffer';
import { store } from '../store';
import { 
  setMiBand3Connection,
  addMiBand3HeartRate,
  setMiBand3Monitoring 
} from '../store/slices/deviceSlice';
import AsyncStorage from '@react-native-async-storage/async-storage';
import CryptoJS from 'crypto-js';
import { PermissionService } from './PermissionService';

// üÜï KALICI VERƒ∞ SAKLAMA KEYS
const STORAGE_KEYS = {
  HEART_RATE_DATA: 'miband3_heart_rate_data',
  SLEEP_SESSIONS: 'miband3_sleep_sessions',
  DEVICE_INFO: 'miband3_device_info',
  LAST_SYNC: 'miband3_last_sync',
};

export class MiBand3Service {
  private bleManager: BleManager;
  private connectedDevice: Device | null = null;
  private isPaired = false;
  private isScanning = false;
  private isMonitoring = false;
  private scannedDevices: Device[] = [];
  private authKey: string | null = null;

  // UUID'ler
  private readonly AUTH_SERVICE_UUID = '0000fee1-0000-1000-8000-00805f9b34fb';
  private readonly AUTH_CHAR_UUID = '00000009-0000-3512-2118-0009af100700';
  
  // Alternative Auth UUIDs (Mi Band 3 variations)
  private readonly AUTH_CHAR_ALT1 = '00000009-0000-3512-2118-0009af100700';
  private readonly AUTH_CHAR_ALT2 = '00000009-0000-1000-8000-00805f9b34fb';
  private readonly AUTH_CHAR_ALT3 = '00000010-0000-3512-2118-0009af100700';
  
  private readonly HR_SERVICE_UUID = '0000180d-0000-1000-8000-00805f9b34fb';
  private readonly HR_CHAR_UUID = '00002a37-0000-1000-8000-00805f9b34fb';
  private readonly HR_CONTROL_UUID = '00002a39-0000-1000-8000-00805f9b34fb';
  
  private readonly USER_INFO_SERVICE_UUID = '0000fee0-0000-1000-8000-00805f9b34fb';
  private readonly USER_INFO_CHAR_UUID = '00000008-0000-3512-2118-0009af100700';

  // üÜï SLEEP DETECTION - Gadgetbridge Protocol
  private readonly SLEEP_DETECTION_SERVICE_UUID = '0000fee0-0000-1000-8000-00805f9b34fb';
  private readonly SLEEP_DETECTION_CHAR_UUID = '00000010-0000-3512-2118-0009af100700';

  // Sleep state tracking
  private currentSleepState: 'AWAKE' | 'ASLEEP' | 'LIGHT_SLEEP' | 'DEEP_SLEEP' = 'AWAKE';
  private sleepStartTime: Date | null = null;
  private sleepHeartRateData: Array<{heartRate: number, timestamp: string}> = [];
  private sleepHeartRateMonitoring: boolean = false;

  // üÜï Periyodik nabƒ±z √∂l√ß√ºm√º i√ßin
  private periodicHRTimer: NodeJS.Timeout | null = null;
  private isPeriodicHRActive: boolean = false;
  private periodicHRInterval: number = 30000; // 30 saniye default
  private periodicHRMonitoring: any = null; // Aktif monitoring referansƒ±
  private isPeriodicMeasuring: boolean = false; // √ñl√ß√ºm sƒ±rasƒ±nda √ßakƒ±≈üma √∂nleme
  private lastHeartRateSavedAtMs: number = 0; // Son kaydedilen HR zamanƒ± (duplikasyon √∂nleme)
  private periodicPausedSleepMonitoring: boolean = false; // Periyodik √∂l√ß√ºm i√ßin sleep monitoring durduruldu mu

  // Periyodik √∂l√ß√ºm i√ßin Sleep HR monitoring'i durdur
  private async pauseSleepMonitoringForPeriodic(): Promise<void> {
    if (this.sleepHeartRateMonitoring) {
      try {
        console.log('‚è∏Ô∏è Sleep HR monitoring periyodik √∂l√ß√ºm i√ßin durduruluyor...');
        await this.stopSleepHeartRateMonitoring();
        this.periodicPausedSleepMonitoring = true;
        console.log('‚úÖ Sleep HR monitoring durduruldu (periyodik)');
      } catch (error) {
        console.log('‚ÑπÔ∏è Sleep HR monitoring durdurulamadƒ± (devam ediliyor):', error);
      }
    }
  }

  // Periyodik √∂l√ß√ºm bittiƒüinde Sleep HR monitoring'i tekrar ba≈ülat
  private resumeSleepMonitoringIfPaused(): void {
    if (this.periodicPausedSleepMonitoring) {
      console.log('‚ñ∂Ô∏è Sleep HR monitoring tekrar ba≈ülatƒ±lƒ±yor (periyodik bitti)...');
      this.startSleepHeartRateMonitoring()
        .then(() => {
          console.log('‚úÖ Sleep HR monitoring tekrar aktif');
        })
        .catch((err) => {
          console.log('‚ö†Ô∏è Sleep HR monitoring tekrar ba≈ülatƒ±lamadƒ±:', err);
        })
        .finally(() => {
          this.periodicPausedSleepMonitoring = false;
        });
    }
  }

  constructor() {
    this.bleManager = new BleManager();
    this.loadAuthKey();
    
    // üÜï Uygulama ba≈üladƒ±ƒüƒ±nda kalƒ±cƒ± verileri y√ºkle
    this.loadPersistedData();
  }

  // Auth key y√∂netimi
  private async loadAuthKey(): Promise<void> {
    try {
      const savedKey = await AsyncStorage.getItem('miband3_auth_key');
      if (savedKey) {
        this.authKey = savedKey;
        console.log('‚úÖ Auth key y√ºklendi:', savedKey.substring(0, 8) + '...');
      } else {
        // Gadgetbridge default key (loglardan)
        this.authKey = '30313233343536373839404142434445';
        await AsyncStorage.setItem('miband3_auth_key', this.authKey);
        console.log('‚úÖ Default auth key kullanƒ±lƒ±yor');
      }
    } catch (error) {
      console.error('‚ùå Auth key y√ºkleme hatasƒ±:', error);
      this.authKey = '30313233343536373839404142434445';
    }
  }

  private async saveAuthKey(key: string): Promise<void> {
    try {
      this.authKey = key;
      await AsyncStorage.setItem('miband3_auth_key', key);
      console.log('‚úÖ Auth key kaydedildi');
    } catch (error) {
      console.error('‚ùå Auth key kaydetme hatasƒ±:', error);
    }
  }

  // Bluetooth durumunu kontrol et
  private async initializeBluetooth(): Promise<void> {
    try {
      const state = await this.bleManager.state();
      console.log('üîµ Bluetooth durumu:', state);
    } catch (error) {
      console.error('‚ùå Bluetooth ba≈ülatma hatasƒ±:', error);
    }
  }

  // Mi Band 3 cihazlarƒ±nƒ± tara
  public async scanForMiBand3Devices(): Promise<Device[]> {
    try {
      console.log('üîç Mi Band 3 tarama ba≈ülatƒ±lƒ±yor...');
      
      // √ñnce Bluetooth tarama gereksinimlerini kontrol et
      const requirements = await PermissionService.checkBluetoothScanRequirements();
      if (!requirements.success) {
        console.error('‚ùå Bluetooth tarama gereksinimleri kar≈üƒ±lanmadƒ±:', requirements.message);
        throw new Error(requirements.message);
      }
      
      console.log('üîç Mi Band 3 taranƒ±yor...');
      this.scannedDevices = [];
      this.isScanning = true;

      return new Promise((resolve, reject) => {
        let scanTimeout: NodeJS.Timeout;
        
        const subscription = this.bleManager.startDeviceScan(
          null,
          { allowDuplicates: false },
          (error, device) => {
            if (error) {
              console.error('‚ùå Tarama hatasƒ±:', error);
              this.isScanning = false;
              if (scanTimeout) clearTimeout(scanTimeout);
              this.bleManager.stopDeviceScan();
              reject(error);
              return;
            }

            if (device && device.name) {
              console.log('üì± Bulunan cihaz:', device.name);
              
              // Mi Band 3 kontrol√º
              if (device.name.includes('Mi Band') || 
                  device.name.includes('Band') ||
                  device.name.includes('Xiaomi')) {
                console.log('‚úÖ Mi Band 3 bulundu:', device.name);
                
                const exists = this.scannedDevices.find(d => d.id === device.id);
                if (!exists) {
                  this.scannedDevices.push(device);
                }
              }
            }
          }
        );

        // 10 saniye sonra taramayƒ± durdur
        scanTimeout = setTimeout(() => {
          this.bleManager.stopDeviceScan();
          this.isScanning = false;
          console.log('‚úÖ Tarama tamamlandƒ±:', this.scannedDevices.length, 'cihaz bulundu');
          resolve(this.scannedDevices);
        }, 10000);
      });
    } catch (error) {
      console.error('‚ùå Tarama hatasƒ±:', error);
      this.isScanning = false;
      throw error;
    }
  }

  // Gadgetbridge Authentication Protocol (Loglardan)
  private async performGadgetbridgeAuth(): Promise<boolean> {
    if (!this.connectedDevice || !this.authKey) {
      throw new Error('Cihaz baƒülƒ± deƒüil veya auth key yok');
    }

    try {
      console.log('üîê Gadgetbridge authentication ba≈ülatƒ±lƒ±yor...');

      // Loglardan alƒ±nan ger√ßek auth key: 79 66 39 6c 70 69 4f 4f 52 31 75 50 64 6b 76 54
      const realAuthKey = '7966396c70694f4f52317550646b7654';
      console.log('üîë Ger√ßek auth key kullanƒ±lƒ±yor:', realAuthKey);

      return new Promise((resolve, reject) => {
        let authStep = 0;
        let authTimeout: NodeJS.Timeout;

        // Auth characteristic notifications'ƒ± aktif et
        this.connectedDevice!.monitorCharacteristicForService(
          this.AUTH_SERVICE_UUID,
          '00000009-0000-3512-2118-0009af100700',
          (error: any, characteristic: any) => {
            if (error) {
              console.error('‚ùå Auth notification hatasƒ±:', error);
              if (authTimeout) clearTimeout(authTimeout);
              reject(error);
              return;
            }
            
            if (characteristic?.value) {
              const data = Buffer.from(characteristic.value, 'base64');
              console.log('üì• Auth response:', data.toString('hex').toUpperCase());
              
              // Step 1 Success response: 10 01 01
              if (data.length >= 3 && data[0] === 0x10 && data[1] === 0x01 && data[2] === 0x01 && authStep === 1) {
                console.log('‚úÖ Authentication Step 1 SUCCESS!');
                authStep = 2;
                this.sendRandomRequest();
              }
              // Random data response: 10 02 01 + 16 bytes random
              else if (data.length >= 3 && data[0] === 0x10 && data[1] === 0x02 && data[2] === 0x01 && authStep === 2) {
                console.log('üì• Random data alƒ±ndƒ±, encryption yapƒ±lƒ±yor...');
                authStep = 3;
                this.handleRandomDataResponse(data, realAuthKey);
              }
              // Final success: 10 03 01
              else if (data.length >= 3 && data[0] === 0x10 && data[1] === 0x03 && data[2] === 0x01 && authStep === 3) {
                console.log('‚úÖ Authentication TAMAMLANDI!');
                if (authTimeout) clearTimeout(authTimeout);
                this.isPaired = true;
                resolve(true);
              }
            }
          }
        );

        // Timeout ayarla (10 saniye)
        authTimeout = setTimeout(() => {
          console.error('‚ùå Authentication timeout!');
          reject(new Error('Authentication timeout'));
        }, 10000);

        // Step 1: Auth key g√∂nder
        this.sendAuthKey(realAuthKey).then(() => {
          authStep = 1;
        }).catch((error) => {
          if (authTimeout) clearTimeout(authTimeout);
          reject(error);
        });
      });
      
    } catch (error) {
      console.error('‚ùå Gadgetbridge auth hatasƒ±:', error);
      return false;
    }
  }

  // Auth key g√∂nder
  private async sendAuthKey(authKey: string): Promise<void> {
    console.log('üì§ Step 1: Auth key g√∂nderiliyor...');
    const authKeyCommand = Buffer.concat([
      Buffer.from([0x01, 0x00]), // Command header
      Buffer.from(authKey, 'hex') // Auth key
    ]);
    
    console.log('üì§ Auth key command:', authKeyCommand.toString('hex').toUpperCase());
    
    await this.connectedDevice!.writeCharacteristicWithoutResponseForService(
      this.AUTH_SERVICE_UUID,
      '00000009-0000-3512-2118-0009af100700',
      authKeyCommand.toString('base64')
    );
  }

  // Random number iste
  private async sendRandomRequest(): Promise<void> {
    console.log('üì§ Step 2: Random number isteniyor...');
    const randomRequest = Buffer.from([0x02, 0x00]);
    
    await this.connectedDevice!.writeCharacteristicWithoutResponseForService(
      this.AUTH_SERVICE_UUID,
      '00000009-0000-3512-2118-0009af100700',
      randomRequest.toString('base64')
    );
  }

  // Random data response handler
  private async handleRandomDataResponse(data: Buffer, authKey: string): Promise<void> {
    try {
      if (data.length >= 19) { // 10 02 01 + 16 bytes random
        const randomData = data.slice(3, 19); // 16 byte random
        console.log('üîê Random data:', randomData.toString('hex').toUpperCase());
        
        // AES-128-ECB ile encrypt et
        const key = CryptoJS.enc.Hex.parse(authKey);
        const dataToEncrypt = CryptoJS.enc.Hex.parse(randomData.toString('hex'));
        
        const encrypted = CryptoJS.AES.encrypt(dataToEncrypt, key, {
          mode: CryptoJS.mode.ECB,
          padding: CryptoJS.pad.NoPadding
        });

        const encryptedBuffer = Buffer.from(encrypted.ciphertext.toString(CryptoJS.enc.Hex), 'hex');
        console.log('üîê Encrypted random:', encryptedBuffer.toString('hex').toUpperCase());

        // 3. Encrypted random g√∂nder (Loglardan: 03 00 + encrypted data)
        const encryptedCommand = Buffer.concat([
          Buffer.from([0x03, 0x00]),
          encryptedBuffer
        ]);

        console.log('üì§ Step 3: Encrypted random g√∂nderiliyor...');
        console.log('üì§ Encrypted command:', encryptedCommand.toString('hex').toUpperCase());

        await this.connectedDevice!.writeCharacteristicWithoutResponseForService(
          this.AUTH_SERVICE_UUID,
          '00000009-0000-3512-2118-0009af100700',
          encryptedCommand.toString('base64')
        );
      }
    } catch (error) {
      console.error('‚ùå Random data handling hatasƒ±:', error);
    }
  }

  // Cihaza baƒülan ve authenticate et
  public async connectToDevice(device: Device): Promise<boolean> {
    try {
      console.log('üîó Baƒülanƒ±yor:', device.name);
      
      // Baƒülantƒ± kur
      this.connectedDevice = await device.connect();
      await this.connectedDevice.discoverAllServicesAndCharacteristics();
      
      console.log('‚úÖ BLE baƒülantƒ± kuruldu');

      // Gadgetbridge authentication
      const authSuccess = await this.performGadgetbridgeAuth();
      
      if (authSuccess) {
        // Redux state g√ºncelle
        store.dispatch(setMiBand3Connection({ connected: true, paired: true }));
        
        // User info ayarla (Gadgetbridge protokol√º + Saat/Tarih)
        await this.setupUserInfo();
        
        // Sleep detection ba≈ülat
        await this.startSleepDetection();
        
        console.log('‚úÖ Mi Band 3 tamamen hazƒ±r!');
        return true;
      } else {
        throw new Error('Authentication ba≈üarƒ±sƒ±z');
      }
      
    } catch (error) {
      console.error('‚ùå Baƒülantƒ± hatasƒ±:', error);
      this.connectedDevice = null;
      this.isPaired = false;
      
      store.dispatch(setMiBand3Connection({ connected: false, paired: false }));
      return false;
    }
  }

  // User info setup (Gadgetbridge protokol√º + Saat/Tarih)
  private async setupUserInfo(): Promise<void> {
    if (!this.connectedDevice) return;

    try {
      console.log('üë§ User info ve saat ayarlarƒ± yapƒ±lƒ±yor...');
      
      // 1. Gadgetbridge user info format
      const userInfo = Buffer.from([
        0x01, // command
        0x01, 0x00, 0x00, 0x00, // user id = 1
        0x01, // gender = male
        0x20, // age = 32
        0xB0, // height = 176cm
        0x4B, // weight = 75kg
        0x00, // type
        0x00, 0x00, 0x00 // padding
      ]);

      await this.connectedDevice.writeCharacteristicWithoutResponseForService(
        this.USER_INFO_SERVICE_UUID,
        this.USER_INFO_CHAR_UUID,
        userInfo.toString('base64')
      );

      console.log('‚úÖ User info ayarlandƒ±');

      // 2. Saat/Tarih ayarla (Current Time Characteristic)
      const now = new Date();
      console.log('üïê ≈ûu anki zaman:', now.toLocaleString('tr-TR', { timeZone: 'Europe/Istanbul' }));
      
      // Gadgetbridge Mi Band 3 format (exact log analysis):
      // E9 07 08 0E 0F 33 23 04 00 00 0C = 2025/08/14 15:51:35 Thursday
      // year(2) month(1) day(1) hour(1) minute(1) second(1) dayOfWeek(1) fractions(1) adjustReason(1) timezone(1)
      
      // Mi Band 3 Day of Week: 1=Monday, 2=Tuesday, 3=Wednesday, 4=Thursday, 5=Friday, 6=Saturday, 7=Sunday
      // JavaScript getDay(): 0=Sunday, 1=Monday, 2=Tuesday, 3=Wednesday, 4=Thursday, 5=Friday, 6=Saturday
      const jsDayOfWeek = now.getDay();
      const miBandDayOfWeek = jsDayOfWeek === 0 ? 7 : jsDayOfWeek;
      
      // Timezone offset: Mi Band 3 timezone format is quarter-hours from UTC
      // Turkey UTC+3 = 3 * 4 = 12 (0x0C)
      const timezoneOffsetQuarterHours = 12; // UTC+3 = 12 quarter-hours
      
      const timeData = Buffer.from([
        now.getFullYear() & 0xFF, // year low byte (little endian)
        (now.getFullYear() >> 8) & 0xFF, // year high byte
        now.getMonth() + 1, // month (1-12)
        now.getDate(), // day (1-31)
        now.getHours(), // hour (0-23)
        now.getMinutes(), // minute (0-59)
        now.getSeconds(), // second (0-59)
        miBandDayOfWeek, // day of week (1=Monday...7=Sunday)
        0x00, // fractions (1/256 second)
        0x00, // adjust reason (0x00 = manual time update)
        timezoneOffsetQuarterHours // timezone offset in quarter-hours from UTC
      ]);

      console.log('üìÖ Time data buffer:', timeData.toString('hex').toUpperCase());
      console.log('üìÖ Detaylar:');
      console.log('  üìÖ Yƒ±l:', now.getFullYear(), `(0x${now.getFullYear().toString(16).toUpperCase()})`);
      console.log('  üìÖ Ay:', now.getMonth() + 1);
      console.log('  üìÖ G√ºn:', now.getDate());
      console.log('  üìÖ Saat:', now.getHours());
      console.log('  üìÖ Dakika:', now.getMinutes());
      console.log('  üìÖ Saniye:', now.getSeconds());
      console.log('  üìÖ Day of week (JS):', jsDayOfWeek, '‚Üí Mi Band:', miBandDayOfWeek);
      console.log('  üìÖ Timezone offset:', `UTC+3 = ${timezoneOffsetQuarterHours} quarter-hours`);

      await this.connectedDevice.writeCharacteristicWithoutResponseForService(
        this.USER_INFO_SERVICE_UUID,
        '00002a2b-0000-1000-8000-00805f9b34fb', // Current Time Characteristic
        timeData.toString('base64')
      );

      console.log('üïê Saat/tarih ayarlandƒ±:', now.toLocaleString('tr-TR', { timeZone: 'Europe/Istanbul' }));

    } catch (error) {
      console.error('‚ùå User info setup hatasƒ±:', error);
    }
  }

  // OPTIMIZED Manuel nabƒ±z √∂l√ß√ºm√º (PROVEN WORKING - Senaryo C Based)
  async triggerHeartRateMeasurement(): Promise<void> {
    console.log('üíì Mi Band 3 Manuel Heart Rate Measurement (OPTIMIZED)');
    
    if (!this.connectedDevice) {
      throw new Error('Mi Band 3 baƒülƒ± deƒüil');
    }

    try {
      // STEP 1: Connection verification
      const isConnected = await this.connectedDevice.isConnected();
      if (!isConnected) {
        throw new Error('Mi Band 3 connection lost');
      }
      console.log('‚úÖ Connection verified');

      // STEP 2: Setup monitoring (auto-enables CCCD)
      console.log('üì° Setting up heart rate monitoring...');
      
      // Reset measurement tracking
      if (this.connectedDevice) {
        (this.connectedDevice as any)._manualMeasurementCount = 0;
        (this.connectedDevice as any)._manualMeasurementStartTime = Date.now();
      }

      const manualMonitoring = this.connectedDevice.monitorCharacteristicForService(
        this.HR_SERVICE_UUID,
        this.HR_CHAR_UUID,
        (error, characteristic) => {
          const elapsed = Date.now() - ((this.connectedDevice as any)?._manualMeasurementStartTime || Date.now());
          (this.connectedDevice as any)._manualMeasurementCount = ((this.connectedDevice as any)._manualMeasurementCount || 0) + 1;
          const count = (this.connectedDevice as any)._manualMeasurementCount;
          
          if (error) {
            console.error(`‚ùå HR monitoring error (${elapsed}ms, #${count}):`, error);
            return;
          }

          if (characteristic?.value) {
            const rawData = Buffer.from(characteristic.value, 'base64');
            console.log(`üìä Raw HR data: ${rawData.toString('hex')} (${elapsed}ms, #${count})`);
            
            if (rawData.length >= 2) {
              const heartRate = rawData[1];
              console.log(`üíì Heart Rate: ${heartRate} BPM (${(elapsed/1000).toFixed(1)}s, #${count})`);
              
              if (heartRate > 0) {
                // Redux dispatch
                store.dispatch(addMiBand3HeartRate({
                  heartRate,
                  timestamp: new Date().toISOString(),
                  sensorContact: true
                }));
                
                // Persistent storage
                this.saveHeartRateData({
                  heartRate,
                  timestamp: new Date().toISOString()
                });
                
                console.log(`üíæ Heart rate saved: ${heartRate} BPM`);
              }
            }
          }
        }
      );

      console.log('‚úÖ Monitoring active');
      
      // STEP 3: Wait for monitoring to stabilize
      await new Promise(resolve => setTimeout(resolve, 300));

      // STEP 4: PROVEN WORKING COMMAND - SENARYO C (Minimal)
      console.log('üì§ Sending heart rate start command (15 02 01)...');
      
      await this.connectedDevice.writeCharacteristicWithResponseForService(
        this.HR_SERVICE_UUID,
        this.HR_CONTROL_UUID,
        Buffer.from([0x15, 0x02, 0x01]).toString('base64')
      );
      
      console.log('‚úÖ Heart rate measurement command sent successfully!');
      console.log('‚è≥ Waiting for heart rate data...');
      console.log('üìä Expected: First result in ~5 seconds, follow-up measurements every ~2 seconds');
      
      // Auto-stop after 30 seconds
      setTimeout(async () => {
        try {
          console.log('‚è∞ 30 seconds elapsed, stopping manual measurement...');
          
                     const finalCount = this.connectedDevice ? (this.connectedDevice as any)._manualMeasurementCount || 0 : 0;
          console.log(`üìä Manual measurement completed: ${finalCount} measurements received`);
          
                                // Stop heart rate measurement
           if (this.connectedDevice) {
             await this.connectedDevice.writeCharacteristicWithResponseForService(
               this.HR_SERVICE_UUID,
               this.HR_CONTROL_UUID,
               Buffer.from([0x15, 0x02, 0x00]).toString('base64')
             );
             console.log('‚úÖ Manual heart rate measurement stopped');
           }
          
        } catch (error) {
          console.log('‚ö†Ô∏è Auto-stop error:', error);
        }
      }, 30000);
      
    } catch (error) {
      console.error('‚ùå Manual heart rate measurement failed:', error);
      throw error;
    }
  }

  // Ger√ßek zamanlƒ± nabƒ±z monit√∂r√ºn√º ba≈ülat (Gadgetbridge Protocol)
  public async startHeartRateMonitoring(): Promise<void> {
    if (!this.connectedDevice || !this.isPaired) {
      console.log('‚ùå Cihaz baƒülƒ± deƒüil veya e≈üle≈ümemi≈ü');
      return;
    }

    try {
      console.log('üîÑ Continuous heart rate monitoring ba≈ülatƒ±lƒ±yor... (Gadgetbridge Protocol)');

      // Heart Rate Measurement notification'ƒ±nƒ± enable et
      await this.connectedDevice.monitorCharacteristicForService(
        this.HR_SERVICE_UUID,
        this.HR_CHAR_UUID,
        (error, characteristic) => {
          if (error) {
            console.error('‚ùå Heart rate monitoring hatasƒ±:', error);
            return;
          }
          
          if (characteristic?.value) {
            const data = Buffer.from(characteristic.value, 'base64');
            
            if (data.length >= 2) {
              const flags = data[0];
              const heartRate = data[1];
              
              console.log(`üíì Continuous HR: ${heartRate} BPM`);
              
              // Redux store'a kaydet
              const heartRateData = {
                heartRate: heartRate,
                timestamp: new Date().toISOString(),
                sensorContact: true
              };
              
              store.dispatch(addMiBand3HeartRate(heartRateData));

              // üÜï Kalƒ±cƒ± depoya da kaydet
              this.saveHeartRateData({
                heartRate: heartRate,
                timestamp: heartRateData.timestamp
              });
            }
          }
        }
      );

      // Continuous monitoring i√ßin komut dizisi
      console.log('üì§ Continuous monitoring commands...');
      
      // Command 1: Enable notifications
      await this.connectedDevice.writeCharacteristicWithoutResponseForService(
        this.HR_SERVICE_UUID,
        this.HR_CONTROL_UUID,
        Buffer.from([0x15, 0x01, 0x01]).toString('base64') // Continuous mode
      );

      await new Promise(resolve => setTimeout(resolve, 100));

      // Command 2: Start continuous measurement
      await this.connectedDevice.writeCharacteristicWithoutResponseForService(
        this.HR_SERVICE_UUID,
        this.HR_CONTROL_UUID,
        Buffer.from([0x15, 0x02, 0x01]).toString('base64')
      );

      this.isMonitoring = true;
      store.dispatch(setMiBand3Monitoring(true));
      
      console.log('‚úÖ Continuous heart rate monitoring aktif! (Gadgetbridge Protocol)');

    } catch (error) {
      console.error('‚ùå Heart rate monitoring ba≈ülatma hatasƒ±:', error);
    }
  }

  // üÜï SLEEP DETECTION - Gadgetbridge Protocol Implementation
  public async startSleepDetection(): Promise<void> {
    if (!this.connectedDevice || !this.isPaired) {
      console.log('‚ùå Cihaz baƒülƒ± deƒüil veya e≈üle≈ümemi≈ü');
      return;
    }

    try {
      console.log('üí§ Sleep detection monitoring ba≈ülatƒ±lƒ±yor... (Gadgetbridge Protocol)');

      // Sleep detection characteristic'ini monitor et
      await this.connectedDevice.monitorCharacteristicForService(
        this.SLEEP_DETECTION_SERVICE_UUID,
        this.SLEEP_DETECTION_CHAR_UUID,
        (error, characteristic) => {
          if (error) {
            console.error('‚ùå Sleep detection monitoring hatasƒ±:', error);
            return;
          }
          
          if (characteristic?.value) {
            const data = Buffer.from(characteristic.value, 'base64');
            console.log('üí§ Sleep detection data:', data.toString('hex').toUpperCase());
            
            if (data.length >= 1) {
              const sleepValue = data[0];
              this.handleSleepStateChange(sleepValue);
            }
          }
        }
      );

      console.log('‚úÖ Sleep detection monitoring aktif!');

    } catch (error) {
      console.error('‚ùå Sleep detection ba≈ülatma hatasƒ±:', error);
    }
  }

  // Sleep state change handler (Gadgetbridge Protocol)
  private async handleSleepStateChange(value: number): Promise<void> {
    const timestamp = new Date();
    let newSleepState: 'AWAKE' | 'ASLEEP' | 'LIGHT_SLEEP' | 'DEEP_SLEEP' = 'AWAKE';
    let eventDescription = '';

    // Gadgetbridge log analysis:
    // 0x0e = "Tick 30 min (?)" - 30 dakika tick
    // 0x01 = "Fell asleep" - Uykuya daldƒ±
    switch (value) {
      case 0x01:
        newSleepState = 'ASLEEP';
        eventDescription = 'Fell asleep';
        break;
      case 0x0e:
        eventDescription = 'Tick 30 min (?)';
        // 30 dakika tick, mevcut durumu koru
        newSleepState = this.currentSleepState;
        break;
      case 0x02:
        newSleepState = 'LIGHT_SLEEP';
        eventDescription = 'Light sleep detected';
        break;
      case 0x03:
        newSleepState = 'DEEP_SLEEP';
        eventDescription = 'Deep sleep detected';
        break;
      case 0x00:
        newSleepState = 'AWAKE';
        eventDescription = 'Woke up';
        break;
      default:
        console.log(`üí§ Unknown sleep value: 0x${value.toString(16).toUpperCase()}`);
        return;
    }

    console.log(`üí§ Sleep State Change: ${eventDescription} (0x${value.toString(16).toUpperCase()})`);
    console.log(`üí§ Previous state: ${this.currentSleepState} ‚Üí New state: ${newSleepState}`);

    // State deƒüi≈üikliƒüi varsa
    if (this.currentSleepState !== newSleepState) {
      const previousState = this.currentSleepState;
      this.currentSleepState = newSleepState;

      // Uyku ba≈üladƒ±ƒüƒ±nda
      if (previousState === 'AWAKE' && newSleepState === 'ASLEEP') {
        console.log('üò¥ Uyku ba≈üladƒ±! Sleep heart rate monitoring ba≈ülatƒ±lƒ±yor...');
        this.sleepStartTime = timestamp;
        this.sleepHeartRateData = []; // Reset sleep HR data
        await this.startSleepHeartRateMonitoring();
      }
      
      // Uyku bitti
      else if (previousState !== 'AWAKE' && newSleepState === 'AWAKE') {
        console.log('üòä Uyku bitti! Sleep heart rate monitoring durduruluyor...');
        await this.stopSleepHeartRateMonitoring();
        await this.processSleepSession();
      }

      // Redux state g√ºncelle
      store.dispatch(setMiBand3Connection({ 
        connected: true, 
        paired: true
      }));
    }

    // 30 dakika tick - uyku sƒ±rasƒ±nda kalp atƒ±≈üƒ± kontrol et
    if (value === 0x0e && this.currentSleepState !== 'AWAKE') {
      console.log('‚è∞ Sleep tick (30 min) - Heart rate durumu kontrol ediliyor...');
      if (!this.sleepHeartRateMonitoring) {
        console.log('üíì Sleep heart rate monitoring yeniden ba≈ülatƒ±lƒ±yor...');
        await this.startSleepHeartRateMonitoring();
      }
    }
  }

  // Uyku sƒ±rasƒ±nda heart rate monitoring (√∂zel mod)
  private async startSleepHeartRateMonitoring(): Promise<void> {
    if (!this.connectedDevice || this.sleepHeartRateMonitoring) {
      return;
    }

    try {
      console.log('üí§üíì Sleep heart rate monitoring ba≈ülatƒ±lƒ±yor...');

      // Heart Rate Measurement notification'ƒ±nƒ± enable et (if not already)
      await this.connectedDevice.monitorCharacteristicForService(
        this.HR_SERVICE_UUID,
        this.HR_CHAR_UUID,
        (error, characteristic) => {
          if (error) {
            console.error('‚ùå Sleep heart rate monitoring hatasƒ±:', error);
            return;
          }
          
          if (characteristic?.value) {
            const data = Buffer.from(characteristic.value, 'base64');
            
            if (data.length >= 2) {
              const flags = data[0];
              const heartRate = data[1];
              
              console.log(`üí§üíì Sleep HR: ${heartRate} BPM`);
              
              // Periyodik √∂l√ß√ºm sƒ±rasƒ±nda sleep verisini kaydetme (duplikasyonu √∂nle)
              if (this.isPeriodicMeasuring || this.isPeriodicHRActive) {
                console.log('‚ÑπÔ∏è Sleep HR kaydƒ± atlandƒ± (periyodik √∂l√ß√ºm aktif)');
                return;
              }

              // 1 saniyeden sƒ±k kaydƒ± engelle (duplikasyon √∂nleme)
              const now = Date.now();
              if (now - this.lastHeartRateSavedAtMs < 1000) {
                console.log('‚ÑπÔ∏è Sleep HR duplikasyon atlandƒ± (<1s)');
                return;
              }
              this.lastHeartRateSavedAtMs = now;

              // Sleep heart rate data'ya kaydet
              const sleepHRData = {
                heartRate: heartRate,
                timestamp: new Date().toISOString()
              };
              
              this.sleepHeartRateData.push(sleepHRData);
              
              // Redux store'a da kaydet (normal format)
              store.dispatch(addMiBand3HeartRate({
                ...sleepHRData,
                sensorContact: true
              }));

              // üÜï Kalƒ±cƒ± depoya da kaydet
              this.saveHeartRateData(sleepHRData);
            }
          }
        }
      );

      // Sleep-specific heart rate commands (daha gentle monitoring)
      await this.connectedDevice.writeCharacteristicWithoutResponseForService(
        this.HR_SERVICE_UUID,
        this.HR_CONTROL_UUID,
        Buffer.from([0x15, 0x01, 0x01]).toString('base64') // Gentle continuous mode
      );

      this.sleepHeartRateMonitoring = true;
      console.log('‚úÖ Sleep heart rate monitoring aktif!');

    } catch (error) {
      console.error('‚ùå Sleep heart rate monitoring ba≈ülatma hatasƒ±:', error);
    }
  }

  // Uyku heart rate monitoring'i durdur
  private async stopSleepHeartRateMonitoring(): Promise<void> {
    if (!this.sleepHeartRateMonitoring || !this.connectedDevice) {
      return;
    }

    try {
      console.log('üí§üíì Sleep heart rate monitoring durduruluyor...');

      // Stop heart rate measurement
      await this.connectedDevice.writeCharacteristicWithoutResponseForService(
        this.HR_SERVICE_UUID,
        this.HR_CONTROL_UUID,
        Buffer.from([0x15, 0x02, 0x00]).toString('base64') // Stop
      );

      this.sleepHeartRateMonitoring = false;
      console.log('‚úÖ Sleep heart rate monitoring durduruldu');

    } catch (error) {
      console.error('‚ùå Sleep heart rate monitoring durdurma hatasƒ±:', error);
    }
  }

  // Uyku seansƒ±nƒ± i≈üle ve kaydet
  private async processSleepSession(): Promise<void> {
    if (!this.sleepStartTime || this.sleepHeartRateData.length === 0) {
      console.log('üí§ ƒ∞≈ülenecek uyku verisi bulunamadƒ±');
      return;
    }

    const sleepEndTime = new Date();
    const sleepDuration = sleepEndTime.getTime() - this.sleepStartTime.getTime();
    const sleepDurationMinutes = Math.floor(sleepDuration / (1000 * 60));

    // Sleep heart rate istatistikleri
    const heartRates = this.sleepHeartRateData.map(hr => hr.heartRate);
    const avgHeartRate = heartRates.reduce((a, b) => a + b, 0) / heartRates.length;
    const minHeartRate = Math.min(...heartRates);
    const maxHeartRate = Math.max(...heartRates);

    const sleepSession = {
      startTime: this.sleepStartTime.toISOString(),
      endTime: sleepEndTime.toISOString(),
      duration: sleepDurationMinutes,
      sleepHeartRate: {
        average: Math.round(avgHeartRate),
        min: minHeartRate,
        max: maxHeartRate,
        values: heartRates,
        times: this.sleepHeartRateData.map(hr => hr.timestamp)
      },
      sampleCount: this.sleepHeartRateData.length
    };

    console.log('üí§ Uyku seansƒ± tamamlandƒ±:', {
      duration: `${Math.floor(sleepDurationMinutes / 60)}s ${sleepDurationMinutes % 60}dk`,
      heartRateAvg: Math.round(avgHeartRate),
      heartRateRange: `${minHeartRate}-${maxHeartRate}`,
      samples: this.sleepHeartRateData.length
    });

    // Redux store'a kaydet
    // TODO: Sleep session dispatch action'ƒ± ekle

    // üÜï Kalƒ±cƒ± depoya da kaydet
    await this.saveSleepSession(sleepSession);

    // Reset
    this.sleepStartTime = null;
    this.sleepHeartRateData = [];
  }

  // Baƒülantƒ±yƒ± kes (Kapsamlƒ± disconnect)
  public async disconnect(): Promise<void> {
    console.log('üîå Mi Band 3 baƒülantƒ±sƒ± kesiliyor...');
    
    if (this.connectedDevice) {
      try {
        // üÜï Step 1: √ñnce t√ºm monitoring'leri durdur
        console.log('‚èπÔ∏è Heart rate monitoring durduruluyor...');
        try {
          await this.connectedDevice.writeCharacteristicWithoutResponseForService(
            this.HR_SERVICE_UUID,
            this.HR_CONTROL_UUID,
            Buffer.from([0x15, 0x02, 0x00]).toString('base64') // Stop heart rate monitoring
          );
          await new Promise(resolve => setTimeout(resolve, 100));
        } catch (error) {
          console.log('‚ÑπÔ∏è Heart rate monitoring durdurma hatasƒ± (normal olabilir)');
        }

        // üÜï Step 2: Sleep monitoring'i de durdur
        if (this.sleepHeartRateMonitoring) {
          console.log('‚èπÔ∏è Sleep heart rate monitoring durduruluyor...');
          await this.stopSleepHeartRateMonitoring();
        }

        // üÜï Step 2.5: Periyodik nabƒ±z √∂l√ß√ºm√ºn√º durdur
        if (this.isPeriodicHRActive) {
          console.log('‚èπÔ∏è Periyodik nabƒ±z √∂l√ß√ºm√º durduruluyor...');
          this.stopPeriodicHeartRateMeasurement();
        }

        // üÜï Step 3: Notification'larƒ± disable et (React Native BLE PLX ile)
        try {
          console.log('üìµ Heart rate notifications disable ediliyor...');
          // React Native BLE PLX'te monitoring durdurma otomatik olarak notification'larƒ± disable eder
          // Bu i≈ülem monitoring durdurulduƒüunda otomatik yapƒ±lƒ±r
          console.log('‚ÑπÔ∏è Notifications otomatik olarak disable edilecek (monitoring durduƒüunda)');
        } catch (error) {
          console.log('‚ÑπÔ∏è Notification disable hatasƒ± (normal olabilir)');
        }

        // üÜï Step 4: Cihaz baƒülantƒ±sƒ±nƒ± kes (GADGETBRIDGE STYLE DISCONNECT)
        console.log('üîå BLE connection kesiliyor... (Gadgetbridge Protocol)');
        
        // √ñnce cihazƒ±n ger√ßek baƒülantƒ± durumunu kontrol et
        const isConnected = await this.connectedDevice.isConnected();
        console.log(`üìä Cihaz baƒülantƒ± durumu: ${isConnected}`);
        
        if (isConnected) {
          console.log('üîå Aktif baƒülantƒ± tespit edildi, Gadgetbridge style disconnect...');
          
          try {
            // Step 1: Gadgetbridge style - Disconnecting BtLEQueue from GATT device
            console.log('üîå Step 1: Disconnecting from GATT device (Gadgetbridge style)...');
            await this.connectedDevice.cancelConnection();
            console.log('‚úÖ Device.cancelConnection() ba≈üarƒ±lƒ±');
          } catch (error) {
            console.log('‚ö†Ô∏è Device.cancelConnection() ba≈üarƒ±sƒ±z:', error);
          }
          
          // Step 2: Gadgetbridge timing (3ms sonra close) 
          await new Promise(resolve => setTimeout(resolve, 5));
          
          try {
            // Step 2: BLE Manager seviyesinde zorla disconnect (Gadgetbridge: unregisterApp equivalent)
            console.log('üîå Step 2: BLE Manager disconnect (unregisterApp equivalent)...');
            await this.bleManager.cancelDeviceConnection(this.connectedDevice.id);
            console.log('‚úÖ BleManager.cancelDeviceConnection() ba≈üarƒ±lƒ±');
          } catch (error) {
            console.log('‚ö†Ô∏è BleManager.cancelDeviceConnection() ba≈üarƒ±sƒ±z:', error);
          }
          
          // Step 3: Gadgetbridge timing (30ms sonra connection state check)
          await new Promise(resolve => setTimeout(resolve, 30));
          
          try {
            const isStillConnected = await this.connectedDevice.isConnected();
            console.log(`üîç Connection state check: ${isStillConnected ? 'CONNECTED' : 'NOT_CONNECTED'}`);
            
            if (isStillConnected) {
              console.log('üö® UYARI: Baƒülantƒ± hala aktif! Manuel restart gerekebilir.');
            } else {
              console.log('‚úÖ Device connection state: NOT_CONNECTED (Gadgetbridge style ba≈üarƒ±lƒ±)');
            }
          } catch (statusError) {
            // Connection check hatasƒ± = b√ºy√ºk ihtimalle ba≈üarƒ±yla kesildi
            console.log('‚úÖ Connection state sorgulanamƒ±yor = B√ºy√ºk ihtimalle NOT_CONNECTED');
          }
          
        } else {
          console.log('‚ÑπÔ∏è Cihaz zaten baƒülƒ± deƒüil');
        }
        
      } catch (error) {
        console.error('‚ùå Baƒülantƒ± kesme hatasƒ±:', error);
      }
      
      // üÜï Step 5: T√ºm state'leri temizle (Gadgetbridge: Queue Dispatch Thread terminated equivalent)
      console.log('üîÑ Queue Dispatch Thread terminated equivalent...');
      this.connectedDevice = null;
      this.isPaired = false;
      this.isMonitoring = false;
      this.sleepHeartRateMonitoring = false;
      this.currentSleepState = 'AWAKE';
      this.sleepStartTime = null;
      this.sleepHeartRateData = [];
      
      // üÜï Step 6: Redux state'i g√ºncelle (Gadgetbridge: broadcast receivers to false)
      console.log('üîÑ Setting broadcast receivers equivalent to: false');
      store.dispatch(setMiBand3Connection({ connected: false, paired: false }));
      store.dispatch(setMiBand3Monitoring(false));

      console.log('‚úÖ Mi Band 3 service state tamamen temizlendi (Gadgetbridge style complete)');
      
      // üÜï Step 7: BLE State refresh (Gadgetbridge: GPS service stopping equivalent)
      try {
        console.log('üîÑ Stopping location service equivalent for all devices...');
        const bleState = await this.bleManager.state();
        console.log(`üìä BLE durumu: ${bleState}`);
        
        if (bleState === 'PoweredOn') {
          console.log('‚úÖ BLE service ready for next connection');
        } else {
          console.log('‚ö†Ô∏è BLE durumu normal deƒüil (restart gerekebilir):', bleState);
        }
      } catch (stateError) {
        console.log('‚ÑπÔ∏è BLE state kontrol√º ba≈üarƒ±sƒ±z (normal disconnect behavior)');
      }
      
      // üÜï Step 8: Final cleanup (Gadgetbridge timing equivalent)
      await new Promise(resolve => setTimeout(resolve, 50));
      console.log('üèÅ Disconnect sequence complete - Ready for new connections');
      
    } else {
      console.log('‚ÑπÔ∏è Zaten baƒülƒ± cihaz yok');
    }
  }

  // üÜï PERƒ∞YODƒ∞K NABIZ √ñL√á√úM√ú Sƒ∞STEMƒ∞

  // Periyodik nabƒ±z √∂l√ß√ºm√ºn√º ba≈ülat (ƒ∞Yƒ∞LE≈ûTƒ∞Rƒ∞LMƒ∞≈û)
  public async startPeriodicHeartRateMeasurement(intervalSeconds: number = 30): Promise<void> {
    if (!this.connectedDevice || !this.isPaired) {
      throw new Error('Mi Band 3 baƒülƒ± deƒüil veya e≈üle≈ümemi≈ü');
    }

    if (this.isPeriodicHRActive) {
      console.log('‚ö†Ô∏è Periyodik nabƒ±z √∂l√ß√ºm√º zaten aktif');
      return;
    }

    try {
      this.periodicHRInterval = intervalSeconds * 1000; // Saniyeyi milisaniyeye √ßevir
      this.isPeriodicHRActive = true;

      console.log(`üîÑ Periyodik nabƒ±z √∂l√ß√ºm√º ba≈ülatƒ±lƒ±yor (${intervalSeconds} saniyede bir)...`);

      // √ñnce kalƒ±cƒ± monitoring kurulumu yap
      await this.setupPeriodicHeartRateMonitoring();

      // ƒ∞lk √∂l√ß√ºm√º hemen tetikle
      await this.triggerPeriodicMeasurement();

      // Periyodik timer ba≈ülat
      this.periodicHRTimer = setInterval(async () => {
        try {
          if (this.connectedDevice && this.isPaired && this.isPeriodicHRActive && !this.isPeriodicMeasuring) {
            console.log(`‚è∞ Periyodik nabƒ±z √∂l√ß√ºm√º (${intervalSeconds}s interval)`);
            await this.triggerPeriodicMeasurement();
          } else if (this.isPeriodicMeasuring) {
            console.log('‚ÑπÔ∏è √ñnceki √∂l√ß√ºm devam ediyor, atlayƒ±m...');
          } else {
            console.log('‚ö†Ô∏è Baƒülantƒ± kesildi, periyodik √∂l√ß√ºm durduruluyor');
            this.stopPeriodicHeartRateMeasurement();
          }
        } catch (error) {
          console.error('‚ùå Periyodik nabƒ±z √∂l√ß√ºm√º hatasƒ±:', error);
        }
      }, this.periodicHRInterval);

      // Redux state g√ºncelle
      store.dispatch(setMiBand3Monitoring(true));

      console.log(`‚úÖ Periyodik nabƒ±z √∂l√ß√ºm√º aktif! (${intervalSeconds} saniyede bir)`);

    } catch (error) {
      console.error('‚ùå Periyodik nabƒ±z √∂l√ß√ºm√º ba≈ülatma hatasƒ±:', error);
      this.isPeriodicHRActive = false;
      throw error;
    }
  }

  // Periyodik nabƒ±z √∂l√ß√ºm√ºn√º durdur (ƒ∞Yƒ∞LE≈ûTƒ∞Rƒ∞LMƒ∞≈û)
  public stopPeriodicHeartRateMeasurement(): void {
    if (!this.isPeriodicHRActive) {
      console.log('‚ÑπÔ∏è Periyodik nabƒ±z √∂l√ß√ºm√º zaten pasif');
      return;
    }

    console.log('‚èπÔ∏è Periyodik nabƒ±z √∂l√ß√ºm√º durduruluyor...');

    // Timer'ƒ± durdur
    if (this.periodicHRTimer) {
      clearInterval(this.periodicHRTimer);
      this.periodicHRTimer = null;
    }

    // Monitoring'i temizle
    if (this.periodicHRMonitoring) {
      try {
        this.periodicHRMonitoring.remove();
        console.log('‚úÖ Periyodik monitoring temizlendi');
      } catch (error) {
        console.log('‚ÑπÔ∏è Monitoring temizleme hatasƒ± (normal olabilir):', error);
      }
      this.periodicHRMonitoring = null;
    }

    // State'leri sƒ±fƒ±rla
    this.isPeriodicHRActive = false;
    this.isPeriodicMeasuring = false;

    // Redux state g√ºncelle
    store.dispatch(setMiBand3Monitoring(false));

    console.log('‚úÖ Periyodik nabƒ±z √∂l√ß√ºm√º tamamen durduruldu');
  }

  // üÜï Kalƒ±cƒ± periyodik monitoring kurulumu
  private async setupPeriodicHeartRateMonitoring(): Promise<void> {
    if (!this.connectedDevice || this.periodicHRMonitoring) {
      return; // Zaten kurulmu≈ü
    }

    try {
      console.log('üì° Periyodik HR monitoring kurulumu...');

      // Periyodik √∂l√ß√ºm s√ºresince sleep monitoring'i durdur
      await this.pauseSleepMonitoringForPeriodic();

      // Kalƒ±cƒ± monitoring kur (sadece bir kez)
      this.periodicHRMonitoring = this.connectedDevice.monitorCharacteristicForService(
        this.HR_SERVICE_UUID,
        this.HR_CHAR_UUID,
        (error, characteristic) => {
          if (error) {
            console.error('‚ùå Periyodik HR monitoring hatasƒ±:', error);
            return;
          }

          if (characteristic?.value && this.isPeriodicMeasuring) {
            const rawData = Buffer.from(characteristic.value, 'base64');
            
            if (rawData.length >= 2) {
              const heartRate = rawData[1];
              console.log(`üíì Periyodik nabƒ±z: ${heartRate} BPM`);
              
              if (heartRate > 0) {
                // √ñl√ß√ºm tamamlandƒ± flag'i
                this.isPeriodicMeasuring = false;
                
                // 1 saniyeden sƒ±k kaydƒ± engelle (duplikasyon √∂nleme)
                const now = Date.now();
                if (now - this.lastHeartRateSavedAtMs < 1000) {
                  console.log('‚ÑπÔ∏è Periyodik HR duplikasyon atlandƒ± (<1s)');
                  return;
                }
                this.lastHeartRateSavedAtMs = now;

                // Redux dispatch
                store.dispatch(addMiBand3HeartRate({
                  heartRate,
                  timestamp: new Date().toISOString(),
                  sensorContact: true
                }));
                
                // Persistent storage
                this.saveHeartRateData({
                  heartRate,
                  timestamp: new Date().toISOString()
                });
                
                console.log(`üíæ Periyodik nabƒ±z kaydedildi: ${heartRate} BPM`);

                // Sleep monitoring'i geri getir (√∂l√ß√ºm ba≈üarƒ±yla tamamlandƒ±)
                this.resumeSleepMonitoringIfPaused();
              }
            }
          }
        }
      );

      console.log('‚úÖ Periyodik HR monitoring kuruldu');

    } catch (error) {
      console.error('‚ùå Periyodik HR monitoring kurulum hatasƒ±:', error);
      throw error;
    }
  }

  // üÜï Periyodik √∂l√ß√ºm tetikleme (sadece komut g√∂nder)
  private async triggerPeriodicMeasurement(): Promise<void> {
    if (!this.connectedDevice || this.isPeriodicMeasuring) {
      return; // Zaten √∂l√ß√ºm yapƒ±lƒ±yor
    }

    try {
      console.log('üíì Periyodik √∂l√ß√ºm tetikleniyor...');
      this.isPeriodicMeasuring = true;

      // Sadece nabƒ±z √∂l√ß√ºm√º komutunu g√∂nder
      await this.connectedDevice.writeCharacteristicWithResponseForService(
        this.HR_SERVICE_UUID,
        this.HR_CONTROL_UUID,
        Buffer.from([0x15, 0x02, 0x01]).toString('base64')
      );

      console.log('‚úÖ Periyodik √∂l√ß√ºm komutu g√∂nderildi');

      // 15 saniye timeout (eƒüer cevap gelmezse)
      setTimeout(() => {
        if (this.isPeriodicMeasuring) {
          console.log('‚è∞ Periyodik √∂l√ß√ºm timeout (15s)');
          this.isPeriodicMeasuring = false;
          // Sleep monitoring'i geri getir (√∂l√ß√ºm tamamlanmadƒ± ama periyot bitti)
          this.resumeSleepMonitoringIfPaused();
        }
      }, 15000);

    } catch (error) {
      console.error('‚ùå Periyodik √∂l√ß√ºm tetikleme hatasƒ±:', error);
      this.isPeriodicMeasuring = false;
      this.resumeSleepMonitoringIfPaused();
      throw error;
    }
  }

  // Durum bilgileri
  public getConnectionStatus(): { connected: boolean; paired: boolean; monitoring: boolean; periodicHR: boolean } {
    return {
      connected: this.connectedDevice !== null,
      paired: this.isPaired,
      monitoring: this.isMonitoring,
      periodicHR: this.isPeriodicHRActive
    };
  }

  public get isConnected(): boolean {
    return this.connectedDevice !== null;
  }

  public get isDevicePaired(): boolean {
    return this.isPaired;
  }

  public get isHeartRateMonitoring(): boolean {
    return this.isMonitoring;
  }

  // üÜï KALICI VERƒ∞ Y√ñNETƒ∞Mƒ∞ METODLARI

  // Kalƒ±cƒ± verileri y√ºkle
  private async loadPersistedData(): Promise<void> {
    try {
      console.log('üíæ Mi Band 3 kalƒ±cƒ± verileri y√ºkleniyor...');

      // Heart rate verilerini y√ºkle
      const heartRateData = await AsyncStorage.getItem(STORAGE_KEYS.HEART_RATE_DATA);
      if (heartRateData) {
        const parsedData = JSON.parse(heartRateData);
        console.log(`üíì ${parsedData.length} adet kalƒ±cƒ± heart rate verisi y√ºklendi`);
        
        // Redux store'a y√ºkle
        parsedData.forEach((data: any) => {
          store.dispatch(addMiBand3HeartRate(data));
        });
      }

      // Uyku session verilerini y√ºkle
      const sleepSessions = await AsyncStorage.getItem(STORAGE_KEYS.SLEEP_SESSIONS);
      if (sleepSessions) {
        const parsedSessions = JSON.parse(sleepSessions);
        console.log(`üò¥ ${parsedSessions.length} adet uyku session verisi y√ºklendi`);
        // TODO: Sleep sessions i√ßin Redux store action'ƒ± ekle
      }

      // Son sync zamanƒ±nƒ± y√ºkle
      const lastSync = await AsyncStorage.getItem(STORAGE_KEYS.LAST_SYNC);
      if (lastSync) {
        console.log(`üîÑ Son sync: ${lastSync}`);
      }

    } catch (error) {
      console.error('‚ùå Kalƒ±cƒ± veri y√ºkleme hatasƒ±:', error);
    }
  }

  // Heart rate verisini kalƒ±cƒ± depola
  private async saveHeartRateData(data: {heartRate: number, timestamp: string}): Promise<void> {
    try {
      // Mevcut verileri al
      const existingData = await AsyncStorage.getItem(STORAGE_KEYS.HEART_RATE_DATA);
      let heartRateArray = existingData ? JSON.parse(existingData) : [];
      
      // Yeni veriyi ekle
      heartRateArray.push(data);
      
      // Son 500 √∂l√ß√ºm√º tut (yakla≈üƒ±k 1-2 haftalƒ±k veri)
      if (heartRateArray.length > 500) {
        heartRateArray = heartRateArray.slice(-500);
      }
      
      // Kaydet
      await AsyncStorage.setItem(STORAGE_KEYS.HEART_RATE_DATA, JSON.stringify(heartRateArray));
      console.log(`üíæ Heart rate verisi kaydedildi: ${data.heartRate} BPM`);
      
    } catch (error) {
      console.error('‚ùå Heart rate veri kaydetme hatasƒ±:', error);
    }
  }

  // Uyku session'ƒ±nƒ± kalƒ±cƒ± depola
  private async saveSleepSession(session: any): Promise<void> {
    try {
      const existingData = await AsyncStorage.getItem(STORAGE_KEYS.SLEEP_SESSIONS);
      let sessionsArray = existingData ? JSON.parse(existingData) : [];
      
      sessionsArray.push(session);
      
      // Son 30 uyku session'ƒ±nƒ± tut (yakla≈üƒ±k 1 aylƒ±k)
      if (sessionsArray.length > 30) {
        sessionsArray = sessionsArray.slice(-30);
      }
      
      await AsyncStorage.setItem(STORAGE_KEYS.SLEEP_SESSIONS, JSON.stringify(sessionsArray));
      console.log(`üíæ Uyku session kaydedildi: ${session.duration} dakika`);
      
    } catch (error) {
      console.error('‚ùå Uyku session kaydetme hatasƒ±:', error);
    }
  }

  // Kalƒ±cƒ± verileri temizle
  public async clearPersistedData(): Promise<void> {
    try {
      console.log('üóëÔ∏è Mi Band 3 kalƒ±cƒ± verileri temizleniyor...');
      
      await AsyncStorage.multiRemove([
        STORAGE_KEYS.HEART_RATE_DATA,
        STORAGE_KEYS.SLEEP_SESSIONS,
        STORAGE_KEYS.DEVICE_INFO,
        STORAGE_KEYS.LAST_SYNC,
      ]);
      
      console.log('‚úÖ Kalƒ±cƒ± veriler temizlendi');
    } catch (error) {
      console.error('‚ùå Kalƒ±cƒ± veri temizleme hatasƒ±:', error);
    }
  }

  // Kalƒ±cƒ± veri istatistikleri
  public async getDataStatistics(): Promise<{heartRateCount: number, sleepSessionCount: number, lastSync: string | null}> {
    try {
      const heartRateData = await AsyncStorage.getItem(STORAGE_KEYS.HEART_RATE_DATA);
      const sleepSessions = await AsyncStorage.getItem(STORAGE_KEYS.SLEEP_SESSIONS);
      const lastSync = await AsyncStorage.getItem(STORAGE_KEYS.LAST_SYNC);
      
      return {
        heartRateCount: heartRateData ? JSON.parse(heartRateData).length : 0,
        sleepSessionCount: sleepSessions ? JSON.parse(sleepSessions).length : 0,
        lastSync: lastSync,
      };
    } catch (error) {
      console.error('‚ùå Veri istatistik alma hatasƒ±:', error);
      return { heartRateCount: 0, sleepSessionCount: 0, lastSync: null };
    }
  }
}

export default new MiBand3Service();
